#include "StdAfx.h"
#include "Transport_Protocol_Handler.H"
#include "Transport_Protocol_State.H"
#include "Instance_IM.H"
#include "MsgConnection.H"


#ifdef _MEMORY_DEBUG
#undef THIS_FILE
#define new	   DEBUG_NEW  
#define malloc DEBUG_MALLOC  
static char THIS_FILE[] = __FILE__;  
#endif // _MEMORY_DEBUG

_im_begin

Transport_Protocol_Handler::Transport_Protocol_Handler( Instance_IM* instance 
											 ,Msg_Connection* connection
											 ,Msg_Connection_Handler* handle
											 ,Transport_Protocol_State* state )
											 : instance_( instance )
											 , connection_( connection )
											 , handle_( handle )
											 , state_( state )
{
}

void Transport_Protocol_Handler::dismiss()
{
	//delete this;
}

int Transport_Protocol_Handler::service()
{
	if( state_ == 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 状态为null") , -1 );

	int r = state_->service( this );
	if( r != 0 )
		state_ = 0;
	return r;
}


int Transport_Protocol_Handler::cancel( )
{
	if( state_ == 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 取消时,状态为null") , -1 );

	if( connection_ == 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 取消时,连接为null") , -1 );

	return ( connection_->transport().cancel() ? 0 : -1 );
}

bool Transport_Protocol_Handler::Running()
{
	return ( state_ == 0 );
}

void Transport_Protocol_Handler::onRead( im_transport_handler_type::read_result_type& result)
{
	if( state_ == 0 )
		ThrowException1( InvalidPointerException , "，state_为null" );
	state_ = state_->transition( this, result , 0 );
	if( state_ == 0 )
	{
		BT_LOG_TRACE( getLogger(), toString() << BT_TEXT("> 写数据状态结束!")  );
		return ;
	}
	instance_->getConcurrencyBridge().putq( this );
}

void Transport_Protocol_Handler::onReadArray(im_transport_handler_type::read_array_result_type& result )
{
	if( state_ == 0 )
		ThrowException1( InvalidPointerException , "，state_为null" );
	state_ = state_->transition( this, result , 0 );
	if( state_ == 0 )
	{
		BT_LOG_TRACE( getLogger(), toString() << BT_TEXT("> 写数据状态结束!")  );
		return ;
	}
	instance_->getConcurrencyBridge().putq( this );

}

void Transport_Protocol_Handler::onWrite(  im_transport_handler_type::write_result_type& result)
{
	if( state_ == 0 )
		ThrowException1( InvalidPointerException , "，state_为null" );
	state_ = state_->transition( this, result , 0 );
		if( state_ == 0 )
	{
		BT_LOG_TRACE( getLogger(), toString() << BT_TEXT("> 写数据状态结束!")  );
		return ;
	}
	instance_->getConcurrencyBridge().putq( this );
}

void Transport_Protocol_Handler::onWriteArray(  im_transport_handler_type::write_array_result_type& result)
{
	if( state_ == 0 )
		ThrowException1( InvalidPointerException , "，state_为null" );
	state_ = state_->transition( this, result , 0 );
		if( state_ == 0 )
	{
		BT_LOG_TRACE( getLogger(), toString() << BT_TEXT("> 写数据状态结束!")  );
		return ;
	}
	instance_->getConcurrencyBridge().putq( this );
}

void Transport_Protocol_Handler::onTransmit(  im_transport_handler_type::transmit_result_type& result )
{
	if( state_ == 0 )
		ThrowException1( InvalidPointerException , "，state_为null" );
	state_ = state_->transition( this, result , 0 );
		if( state_ == 0 )
	{
		BT_LOG_TRACE( getLogger(), toString() << BT_TEXT("> 写数据状态结束!")  );
		return ;
	}
	instance_->getConcurrencyBridge().putq( this );
}

void Transport_Protocol_Handler::setHandler( Msg_Connection_Handler* handle )
{
	handle_ = handle;
}

void Transport_Protocol_Handler::setConnection( Msg_Connection* connection )
{
	connection_ = connection;
}

void Transport_Protocol_Handler::setInstance( Instance_IM* instance )
{
	instance_ = instance;
}

void Transport_Protocol_Handler::setState( Transport_Protocol_State* state )
{
	state_ = state;
}

const tstring& Transport_Protocol_Handler::toString() const
{
	if( connection_ == 0 )
		ThrowException1( InvalidPointerException , "，connection为空" );

	return connection_->toString();
}

Msg_Connection::LoggerPtr Transport_Protocol_Handler::getLogger()
{
	if( connection_ == 0 )
		ThrowException1( InvalidPointerException , "，connection为空" );

	return connection_->getLogger();
}

Transport_Read_Protocol_Handler::Transport_Read_Protocol_Handler( Instance_IM* instance
		,Msg_Connection* connection
		,Msg_Connection_Handler* handle )
		: Transport_Protocol_Handler( instance, connection, handle, 0 )
		, buf_( 0 )
{
}

int Transport_Read_Protocol_Handler::service( Bit_Read_Buffer& buf, void* act )
{
	if( state_ != 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能同时两次读数据!") , -1 );
	if( buf_ != 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能同时两次读数据!") , -1 );

	buf.clear();
	length_ = sizeof( DataHeader );
	act_ = act;
	buf_ = &buf;

	buf.resize( sizeof( DataHeader ), sizeof( DataHeader ) );
	BT_ASSERT( getLogger(),  buf.rd_size() == 1 , BT_TEXT("读消息时，重分配内存失败!") );
	for( size_t i = 0; i < buf.rd_size(); i ++ )
	{
		vec_buf_.push_back( buf.rd_vec()[i] );
	}
	BT_ASSERT(  getLogger(), vec_buf_.size() == 1, BT_TEXT("读消息时，重分配内存失败!") );

	state_ = Transport_Read_Header_State::get();
	return Transport_Protocol_Handler::service( );
}

void Transport_Read_Protocol_Handler::dispatchMessage( Msg_Connection_Handler& handler , const DataHeader& ph, Msg_Read_Result& result )
{
	switch( ph.messageType )
	{
	case  im_message:
		handler.onReadMessage( result );
		break;
	case im_present:
		handler.onReadPresent( result );
		break;
	case im_iq:
		handler.onReadIQ( result );
		break;
	case im_x:
		handler.onReadX( result );
		break;
	default:
		{
			handler.onException( result );
		}
	}
}

void Transport_Read_Protocol_Handler::resetBuffer( size_t len , size_t header )
{
	buf_->resize( len , 0 );
	
	for( size_t i = 0; i < buf_->rd_size(); i ++ )
	{
		if( header == 0 )
		{
			vec_buf_.push_back( buf_->rd_vec()[i] );
		}
		else if( header >= buf_->rd_vec()[i].len )
		{
			header -= buf_->rd_vec()[i].len;
		}
		else
		{
			iovec v = buf_->rd_vec()[ i ];
			v.buf += header;
			v.len -= header;
			header = 0;
			vec_buf_.push_back( v );
		}
	}
	length_ = len;
}

const DataHeader* Transport_Read_Protocol_Handler::getHeader()
{
	return ( const DataHeader* )buf_->rd_vec()->buf;
}

Transport_Write_Protocol_Handler::Transport_Write_Protocol_Handler( Instance_IM* instance
		,Msg_Connection* connection
		,Msg_Connection_Handler* handle )
		: Transport_Protocol_Handler( instance, connection, handle,0 )
		, buf_( 0 )
{
}

int Transport_Write_Protocol_Handler::service( const Bit_Write_Buffer& buf, void* act )
{
	if( state_ != 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能同时两次写数据!") , -1 );
	if( buf_ != 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能同时两次写数据!") , -1 );
	if( buf.length() == 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能发送0字节!") , -1 );

	act_ = act;
	buf_ = &buf;
	
	for( size_t i = 0; i < buf.rd_size(); i ++ )
	{
		vec_buf_.push_back( ( ( iovec*) buf.rd_vec() )[i] );
	}

	state_ = Transport_Write_State::get();
	return Transport_Protocol_Handler::service( );
}



_im_end