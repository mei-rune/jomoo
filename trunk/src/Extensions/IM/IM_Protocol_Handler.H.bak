
#ifndef IM_PROTOCOL_HANDLER_H
#define IM_PROTOCOL_HANDLER_H

#include "config.h"

#if !defined (BOE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* BOE_LACKS_PRAGMA_ONCE */

// Include files
#include "config_IM.h"
#include "BOE/Kernel/Kernel.H"
#include "BOE/IO/Networks/Networks.h"

/**
 */
_im_begin

class IM_Buffer;
class IM_Connection_Handler;
class IM_Connection;
class Instance_IM;

class IM_Read_Protocol_Handler;
class IM_Write_Protocol_Handler;

class TcpConnection_Read_Header_State : public _kernel BOE_Protocol_State_T< IM_Read_Protocol_Handler, TCP_Read_Result >
{
public:
	static TcpConnection_Read_Header_State* get();

	int service( IM_Read_Protocol_Handler& handle );

	BOE_Protocol_State* transition( IM_Read_Protocol_Handler& data, TCP_Read_Result& result , void* act );
};

class TcpConnection_Read_Body_State : public _kernel BOE_Protocol_State_T< IM_Read_Protocol_Handler, TCP_Read_Result >
{
public:
	static TcpConnection_Read_Body_State* get();
	
	int service( IM_Read_Protocol_Handler& handle );

	BOE_Protocol_State* transition( IM_Read_Protocol_Handler& data, TCP_Read_Result& result , void* act );
};

class TcpConnection_Write_State : public _kernel BOE_Protocol_State_T< IM_Write_Protocol_Handler, TCP_Write_Result >
{
public:

	static TcpConnection_Write_State* get();

	int service( IM_Write_Protocol_Handler& handle );

	BOE_Protocol_State* transition( IM_Write_Protocol_Handler& data, TCP_Write_Result& result , void* act );
};

class IM_Protocol_Handler : public BOE_Protocol_Handler
							, public TCP_Transport_Handler
{
public:

	IM_Protocol_Handler( Instance_IM* instance = 0
		,IM_Connection* connection = 0
		,IM_Connection_Handler* handle = 0
		,BOE_Protocol_State* state = 0 );

	void dismiss();

	int service();

	void onRead(TCP_Read_Result& result) ;

	void onReadArray(TCP_Read_Array_Result& result ) ;

	void onWrite(TCP_Write_Result& result) ;

	void onWriteArray(TCP_Write_Array_Result& result) ;

	void onTransmit(TCP_Transmit_Result& result ) ;

	void setHandler( IM_Connection_Handler* handle );

	void setConnection( IM_Connection* handle );

	void setInstance( Instance_IM* handle );

	void setState( BOE_Protocol_State* state );

	const tstring& toString() const ;

	IMLoggerPtr getLogger();

protected:

	friend class TcpConnection_Read_Header_State;
	friend class TcpConnection_Read_Body_State;
	friend class TcpConnection_Write_State;


	Instance_IM* instance_;

	IM_Connection* connection_;

	IM_Connection_Handler* handle_;

	BOE_Protocol_State* state_;

	void* act_;
};


class IM_Read_Protocol_Handler : public IM_Protocol_Handler
{
public:

	IM_Read_Protocol_Handler( Instance_IM* instance = 0
		,IM_Connection* connection = 0
		,IM_Connection_Handler* handle = 0 );

	int service( IM_Buffer& buf, void* act );

	void onRead(TCP_Read_Result& result) ;

private:

	friend class TcpConnection_Read_Header_State;
	friend class TcpConnection_Read_Body_State;
	friend class TcpConnection_Write_State;

	IM_Buffer* buf_;
};



class IM_Write_Protocol_Handler : public IM_Protocol_Handler
{
public:

	IM_Write_Protocol_Handler( Instance_IM* instance = 0
		,IM_Connection* connection = 0
		,IM_Connection_Handler* handle = 0  );

	int service(  const IM_Buffer& buf, void* act );

	void onWrite(TCP_Write_Result& result ) ;

private:

	friend class TcpConnection_Read_Header_State;
	friend class TcpConnection_Read_Body_State;
	friend class TcpConnection_Write_State;

	const IM_Buffer* buf_;
	size_t len_;

};

_im_end

#endif // IM_PROTOCOL_HANDLER_H