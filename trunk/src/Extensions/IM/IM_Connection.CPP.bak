
#include "StdAfx.h"
#include "BOE/exception.hpp"
#include "IM_Connection.H"

#ifdef _MEMORY_DEBUG
#undef THIS_FILE
#define new	   DEBUG_NEW  
#define malloc DEBUG_MALLOC  
static char THIS_FILE[] = __FILE__;  
#endif // _MEMORY_DEBUG

_im_begin

IM_Buffer::IM_Buffer( void* buf, size_t size )
: buf_( ( char* )buf )
, size_( size )
, begin_( 0 )
, end_( 0 )
{
}

IM_Buffer::IM_Buffer( void* buf, size_t size , size_t length )
: buf_( ( char* )buf )
, size_( size )
, begin_( 0 )
, end_( length )
{
}

IM_Buffer::IM_Buffer( void* buf, size_t size, size_t begin, size_t end )
: buf_( ( char* ) buf )
, size_( size )
, begin_( begin )
, end_( end )
{
}

const void* IM_Buffer::rd_ptr( ) const
{
	return buf_ + begin_;
}

void IM_Buffer::rd_ptr( size_t len )
{
	if( length() < len )
		ThrowException1( LengthException , ",可读数据没有这么长" );
	begin_ += len;
}

size_t IM_Buffer::length( ) const
{
	return ( end_ - begin_ );
}

void* IM_Buffer::wd_ptr( )
{
	return ( buf_ + end_);
}

void IM_Buffer::wd_ptr( size_t len )
{
	if( space() < len )
		ThrowException1( LengthException , ",可写内存没有这么长" );
	end_ += len;
}

size_t IM_Buffer::space() const
{
	return (size_ - end_ );
}

void IM_Buffer::crunch( )
{
	if( begin_ == 0 )
		return ;
	memmove( buf_, buf_  + begin_, ( end_ - begin_ ) );
	end_ = ( end_ - begin_ );
	begin_ = 0;
}

IM_Connection_Result::IM_Connection_Result( bool success 
		,int err 
		,void* act 
		,const char* name  )
		: success_( success )
		, error_( err )
		, act_( act )
		, toString_( name == 0 ? "" : name )
{
}

IM_Connection_Result::~IM_Connection_Result()
{
}

bool IM_Connection_Result::success( )const
{
	return success_;
}

void* IM_Connection_Result::act()
{
	return act_;
}

const void* IM_Connection_Result::act() const
{
	return act_;
}

const tstring& IM_Connection_Result::toString() const
{
	return toString_;
}

int IM_Connection_Result::error() const
{
	return error_;
}

void IM_Connection_Result::set( bool success,int error,void* act )
{
	success_ = success;
	error_ = error;
	act_ = act;
}

IM_Connection_Read_Result::IM_Connection_Read_Result( IM_Buffer& buffer
		,IM_Connection_Handler& handle
		,IM_Connection& connection )
: buffer_( buffer )
, handle_( handle )
, connection_( connection )
{
}

IM_Buffer& IM_Connection_Read_Result::get()
{
	return buffer_;
}

IM_Connection_Handler& IM_Connection_Read_Result::handle()
{
	return handle_;
}

IM_Connection& IM_Connection_Read_Result::connection()
{
	return connection_;
}

IM_Connection_Write_Result::IM_Connection_Write_Result( const IM_Buffer& buffer
		,IM_Connection_Handler& handle
		,IM_Connection& connection )
: buffer_( buffer )
, handle_( handle )
, connection_( connection )
{
}

const IM_Buffer& IM_Connection_Write_Result::get() const
{
	return buffer_;
}

IM_Connection_Handler& IM_Connection_Write_Result::handle()
{
	return handle_;
}

IM_Connection& IM_Connection_Write_Result::connection()
{
	return connection_;
}

IM_Connection::IM_Connection( Instance_IM& instance, TcpTransportPtr transport, const tchar* name )
: instance_( instance )
, transport_( transport )
, rd_( &instance )
, wd_( &instance )
, toString_( name == 0 ? "<IM_Connection>" : name )
{
	rd_.setConnection( this );
	wd_.setConnection( this );
}

IM_Connection::~IM_Connection(void)
{
}

int IM_Connection::open(  )
{
	return -1;
}

void IM_Connection::close( )
{
}

bool IM_Connection::read( IM_Connection_Handler& handler, IM_Buffer& buf, void* act )
{
	rd_.setHandler( &handler );
	return rd_.service( buf, act ) == 0;
}

bool IM_Connection::write( IM_Connection_Handler& handler, const IM_Buffer& buf, void* act)
{
	wd_.setHandler( &handler );
	return wd_.service( buf , act ) ==0 ;
}

TcpTransportPtr IM_Connection::transport()
{
	return transport_;
}

IM_Connection::LoggerPtr IM_Connection::getLogger()
{
	return instance_.getLogger();
}

const tstring& IM_Connection::toString( ) const
{
	return toString_;
}

_im_end