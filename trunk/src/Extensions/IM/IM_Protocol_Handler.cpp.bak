#include "StdAfx.h"
#include "IM_Protocol_Handler.H"
#include "Instance_IM.H"
#include "IM_Connection.H"


#ifdef _MEMORY_DEBUG
#undef THIS_FILE
#define new	   DEBUG_NEW  
#define malloc DEBUG_MALLOC  
static char THIS_FILE[] = __FILE__;  
#endif // _MEMORY_DEBUG

_im_begin

TcpConnection_Read_Header_State* TcpConnection_Read_Header_State::get()
{
	static TcpConnection_Read_Header_State state;
	return &state;
}

int TcpConnection_Read_Header_State::service( IM_Read_Protocol_Handler& data )
{
	if( data.buf_ == 0 )
		BT_LOG_ERROR_RETURN( data.getLogger(), 
		data.toString() << BT_TEXT("> buf为空!") , -1 );

	return data.connection_->transport()->read( data,data.buf_->wd_ptr()
		,(  sizeof( DataHeader ) - data.buf_->length() ), 0 );
}

BOE_Protocol_State* TcpConnection_Read_Header_State::transition( IM_Read_Protocol_Handler& data, TCP_Read_Result& result , void* act )
{
	if( !result.success() || result.bytes_to_transferred() == 0 )
	{
		/// Tcp错误
		IM_Connection_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_SYS, data.act_ );
		data.handle_->onRead( r );
		return 0;
	}

	data.buf_->wd_ptr( result.bytes_to_transferred() );

	if( data.buf_->length() > sizeof( DataHeader ) )
	{
		/// 多读了数据，一般这是不可能的
		IM_Connection_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_LEN, data.act_ );
		data.handle_->onRead( r );

		return 0;
	}
	if( data.buf_->length() < sizeof( DataHeader ) )
		return get();  /// 没有读全，继续读下去

	// 检测内存空间是否足够
	const DataHeader* ph = ( const DataHeader* ) data.buf_->rd_ptr();
	if( ph->messageSize > data.instance_->getDefaultsAndOverrides().maxMessageSize
		|| ph->messageSize > data.buf_->space() )
	{
		/// 消息长度太长，太于配置值，或大于数据块的长度
		IM_Connection_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_MAXMSGLEN, data.act_ );
		data.handle_->onRead( r );
		return 0;
	}

	if( ph->messageSize == data.buf_->length() )
	{
		// 读消息完成
		IM_Connection_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( true, 0 , data.act_);
		data.handle_->onRead( r );
		return 0;
	}

	/// 消息头读完成，开始读消息体
	return TcpConnection_Read_Body_State::get();
}

TcpConnection_Read_Body_State* TcpConnection_Read_Body_State::get()
{
	static TcpConnection_Read_Body_State state;
	return &state;
}

int TcpConnection_Read_Body_State::service( IM_Read_Protocol_Handler& data )
{
	if( data.buf_ == 0 )
		BT_LOG_ERROR_RETURN( data.getLogger(), 
		data.toString() << BT_TEXT("> buf为空!") , -1 );

	const DataHeader* ph = ( const DataHeader* ) data.buf_->rd_ptr();
	
	return data.connection_->transport()->read( data,data.buf_->wd_ptr()
		, ph->messageSize -( data.buf_->length() ) ,0);
}

BOE_Protocol_State* TcpConnection_Read_Body_State::transition( 
	IM_Read_Protocol_Handler& data, TCP_Read_Result& result , void* act )
{
	if( !result.success() || result.bytes_to_transferred() == 0 )
	{
		/// Tcp错误
		IM_Connection_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_SYS, data.act_ );
		data.handle_->onRead( r );
		return 0;
	}

	data.buf_->wd_ptr( result.bytes_to_transferred() );

	const DataHeader* ph = ( const DataHeader* ) data.buf_->rd_ptr();

	if( data.buf_->length() > ph->messageSize )
	{
		/// 多读了数据，一般这是不可能的
		IM_Connection_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_));
		r.set( false, ERR_LEN, data.act_  );
		data.handle_->onRead( r );
		return 0;
	}

	if( data.buf_->length() < ph->messageSize )
		return get();   /// 没有读全，继续读下去

	/// 消息读完成
		IM_Connection_Read_Result r( *(data.buf_),
			*(data.handle_) ,*(data.connection_));
		r.set( true, 0 , data.act_ );
		data.handle_->onRead( r );
	return 0;
}


TcpConnection_Write_State* TcpConnection_Write_State::get()
{
	static TcpConnection_Write_State state;
	return &state;
}

int TcpConnection_Write_State::service( IM_Write_Protocol_Handler& data )
{
	if( data.buf_ == 0 )
		BT_LOG_ERROR_RETURN( data.getLogger(), 
		data.toString() << BT_TEXT("> buf为空!") , -1 );

	return data.connection_->transport()->write( data, data.buf_->rd_ptr(),data.len_ , 0 );
}

BOE_Protocol_State* TcpConnection_Write_State::transition( 
	IM_Write_Protocol_Handler& data, TCP_Write_Result& result , void* act )
{
	if( !result.success() || result.bytes_to_transferred() == 0 )
	{
		/// Tcp错误
		IM_Connection_Write_Result r( *(data.buf_),
			*(data.handle_) ,*(data.connection_));
		r.set( false, ERR_SYS, data.act_  );
		data.handle_->onWrite( r );
		return 0;
	}

	if( data.len_ < result.bytes_to_transferred() )
	{
		/// 多发送了数据，这一般是不可能的
		IM_Connection_Write_Result r( *(data.buf_),
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_LEN, data.act_ );
		data.handle_->onWrite( r );
		return 0;
	}
	data.len_ -= result.bytes_to_transferred();

	if( data.len_ > 0 )
		return get();

	/// 发送完成
	IM_Connection_Write_Result r( *(data.buf_),
		*(data.handle_) ,*(data.connection_) );
	r.set( true, 0 , data.act_);
	data.handle_->onWrite( r );
	return 0;
}

IM_Protocol_Handler::IM_Protocol_Handler( Instance_IM* instance 
											 ,IM_Connection* connection
											 ,IM_Connection_Handler* handle
											 ,BOE_Protocol_State* state )
											 : instance_( instance )
											 , connection_( connection )
											 , handle_( handle )
											 , state_( state )
{
}

void IM_Protocol_Handler::dismiss()
{
	//delete this;
}

int IM_Protocol_Handler::service()
{
	if( state_ == 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 未知的读结果") , -1 );

	return state_->service( this );
}

void IM_Protocol_Handler::onRead(TCP_Read_Result& result)
{
	BT_LOG_ERROR( getLogger(), toString() << BT_TEXT("> 未知的读结果")  );
}

void IM_Protocol_Handler::onReadArray(TCP_Read_Array_Result& result )
{
	BT_LOG_ERROR( getLogger(), toString() << BT_TEXT("> 未知的读数组结果")  );
}

void IM_Protocol_Handler::onWrite(TCP_Write_Result& result)
{
	BT_LOG_ERROR( getLogger(), toString() << BT_TEXT("> 未知的写结果")  );
}

void IM_Protocol_Handler::onWriteArray(TCP_Write_Array_Result& result)
{
	BT_LOG_ERROR( getLogger(), toString() << BT_TEXT("> 未知的写结果")  );
}

void IM_Protocol_Handler::onTransmit(TCP_Transmit_Result& result )
{
	BT_LOG_ERROR( getLogger(), toString() << BT_TEXT("> 未知的写数组结果")  );
}

void IM_Protocol_Handler::setHandler( IM_Connection_Handler* handle )
{
	handle_ = handle;
}

void IM_Protocol_Handler::setConnection( IM_Connection* connection )
{
	connection_ = connection;
}

void IM_Protocol_Handler::setInstance( Instance_IM* instance )
{
	instance_ = instance;
}

void IM_Protocol_Handler::setState( BOE_Protocol_State* state )
{
	state_ = state;
}

const tstring& IM_Protocol_Handler::toString() const
{
	if( connection_ == 0 )
		ThrowException1( InvalidPointerException , "，connection为空" );

	return connection_->toString();
}

IM_Connection::LoggerPtr IM_Protocol_Handler::getLogger()
{
	if( connection_ == 0 )
		ThrowException1( InvalidPointerException , "，connection为空" );

	return connection_->getLogger();
}

IM_Read_Protocol_Handler::IM_Read_Protocol_Handler( Instance_IM* instance
		,IM_Connection* connection
		,IM_Connection_Handler* handle )
		: IM_Protocol_Handler( instance, connection, handle, 0 )
		, buf_( 0 )
{
}

int IM_Read_Protocol_Handler::service( IM_Buffer& buf, void* act )
{
	if( state_ != 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能同时两次读数据!") , -1 );
	if( buf_ != 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能同时两次读数据!") , -1 );

	if( buf.space() < sizeof( DataHeader ) )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 读内存块太小!") , -1 );


	state_ = TcpConnection_Read_Header_State::get();
	act_ = act;
	buf_ = &buf;
	return state_->service( this );
}

void IM_Read_Protocol_Handler::onRead(TCP_Read_Result& result)
{
	state_ = state_->transition( this, &result ,0  );
	if( state_ == 0 )
	{
		buf_ = 0;
		BT_LOG_TRACE( getLogger(), toString() << BT_TEXT("> 读数据状态结束!")  );
		return ;
	}
	instance_->getConcurrencyBridge().putq( this );
}

IM_Write_Protocol_Handler::IM_Write_Protocol_Handler( Instance_IM* instance
		,IM_Connection* connection
		,IM_Connection_Handler* handle )
		: IM_Protocol_Handler( instance, connection, handle,0 )
		, buf_( 0 )
{
}

int IM_Write_Protocol_Handler::service( const IM_Buffer& buf, void* act )
{
	if( state_ != 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能同时两次写数据!") , -1 );
	if( buf_ != 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能同时两次写数据!") , -1 );
	if( buf.length() == 0 )
		BT_LOG_ERROR_RETURN( getLogger(), toString() << BT_TEXT("> 不能发送0字节!") , -1 );

	state_ = TcpConnection_Write_State::get();
	act_ = act;
	buf_ = &buf;
	len_ = buf.length();
	return state_->service( this );
}

void IM_Write_Protocol_Handler::onWrite(TCP_Write_Result& result )
{
	state_ = state_->transition( this, &result ,0  );
	if( state_ == 0 )
	{
		buf_ = 0;
		BT_LOG_TRACE( getLogger(), toString() << BT_TEXT("> 写数据状态结束!")  );
		return ;
	}
	instance_->getConcurrencyBridge().putq( this );
}

_im_end