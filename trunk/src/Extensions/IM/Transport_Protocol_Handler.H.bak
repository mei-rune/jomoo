
#ifndef IM_Transport_Protocol_Handler_H
#define IM_Transport_Protocol_Handler_H

#include "config.h"

#if !defined (BOE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* BOE_LACKS_PRAGMA_ONCE */

// Include files
#include "config_IM.h"
#include "BOE/Kernel/Kernel.H"
#include "BOE/IO/IO.h"
#include "DataHeader.H"
/**
 */
_im_begin

class Packet_Buffer;
typedef Packet_Buffer Bit_Read_Buffer;
typedef Packet_Buffer Bit_Write_Buffer;
class Msg_Connection_Handler;
class Msg_Connection;
class Instance_IM;
class Msg_Read_Result;
class Msg_Write_Result;

typedef BOE_Transport_Handler im_transport_handler_type;


class Transport_Protocol_State
{
public:
	
	virtual ~Transport_Protocol_State(){}

	virtual int service( void* data ) = 0;

	virtual Transport_Protocol_State* transition(  void* data, im_transport_handler_type::read_result_type& result , void* act ) = 0;

	virtual Transport_Protocol_State* transition(  void* data, im_transport_handler_type::read_array_result_type& result , void* act ) = 0;

	virtual Transport_Protocol_State* transition(  void* data, im_transport_handler_type::write_result_type& result , void* act ) = 0;

	virtual Transport_Protocol_State* transition(  void* data, im_transport_handler_type::write_array_result_type& result , void* act ) = 0;

	virtual Transport_Protocol_State* transition(  void* data, im_transport_handler_type::transmit_result_type& result , void* act ) = 0;
};

template< typename D >
class Transport_Protocol_State_T : public Transport_Protocol_State
{
public:
	virtual ~Transport_Protocol_State_T(){}

	virtual int service( void* data )
	{
		return service( *( D*) data );
	}

	virtual Transport_Protocol_State* transition( void* data, typename im_transport_handler_type::read_result_type& result , void* act )
	{
		return transition( *( D*) data ,result, act );
	}

	virtual Transport_Protocol_State* transition( void* data, typename im_transport_handler_type::read_array_result_type& result , void* act )
	{
		return transition( *( D*) data ,result, act );
	}

	virtual Transport_Protocol_State* transition( void* data, typename im_transport_handler_type::write_result_type& result , void* act )
	{
		return transition( *( D*) data ,result, act );
	}

	virtual Transport_Protocol_State* transition( void* data, typename im_transport_handler_type::write_array_result_type& result , void* act )
	{
		return transition( *( D*) data ,result, act );
	}

	virtual Transport_Protocol_State* transition( void* data, typename im_transport_handler_type::transmit_result_type& result , void* act )
	{
		return transition( *( D*) data ,result, act );
	}

	virtual int service( D& handle )
	{
		BT_LOG_ERROR( handle.getLogger(), handle.toString() << BT_TEXT("> 未定义的操作")  );
		return -1;
	}

	virtual Transport_Protocol_State* transition( D& data, typename im_transport_handler_type::read_result_type& result , void* act )
	{
		BT_LOG_ERROR( data.getLogger(), data.toString() << BT_TEXT("> 未知的读结果")  );
		return 0;
	}

	virtual Transport_Protocol_State* transition( D& data, typename im_transport_handler_type::read_array_result_type& result , void* act )
	{
		BT_LOG_ERROR( data.getLogger(), data.toString() << BT_TEXT("> 未知的读数组结果")  );
		return 0;
	}

	virtual Transport_Protocol_State* transition( D& data, typename im_transport_handler_type::write_result_type& result , void* act )
	{
		BT_LOG_ERROR( data.getLogger(), data.toString() << BT_TEXT("> 未知的写结果")  );
		return 0;
	}

	virtual Transport_Protocol_State* transition( D& data, typename im_transport_handler_type::write_array_result_type& result , void* act )
	{
		BT_LOG_ERROR( data.getLogger(), data.toString() << BT_TEXT("> 未知的写数组结果")  );
		return 0;
	}

	virtual Transport_Protocol_State* transition( D& data, typename im_transport_handler_type::transmit_result_type& result , void* act )
	{
		BT_LOG_ERROR( data.getLogger(), data.toString() << BT_TEXT("> 未知的传输结果")  );
		return 0;
	}
};


class Transport_Protocol_Handler : public BOE_Transport_Handler
									, public BOE_Protocol_Handler
{
public:

	Transport_Protocol_Handler( Instance_IM* instance = 0
		,Msg_Connection* connection = 0
		,Msg_Connection_Handler* handle = 0
		,Transport_Protocol_State* state = 0 );

	void dismiss();

	int service();

	int cancel( );

	bool Running();

	void onRead( im_transport_handler_type::read_result_type& result);

	void onReadArray( im_transport_handler_type::read_array_result_type& result ) ;

	void onWrite( im_transport_handler_type::write_result_type& result) ;

	void onWriteArray( im_transport_handler_type::write_array_result_type& result) ;

	void onTransmit( im_transport_handler_type::transmit_result_type& result ) ;

	void setHandler( Msg_Connection_Handler* handle );

	void setConnection( Msg_Connection* handle );

	void setInstance( Instance_IM* handle );

	void setState( Transport_Protocol_State * state );

	const tstring& toString() const ;

	IMLoggerPtr getLogger();

protected:


	friend class Transport_Read_Header_State;
	friend class Transport_Read_Body_State;
	friend class Transport_Write_State;


	Instance_IM* instance_;

	Msg_Connection* connection_;

	Msg_Connection_Handler* handle_;

	Transport_Protocol_State* state_;

	void* act_;
};


class Transport_Read_Protocol_Handler : public Transport_Protocol_Handler
{
public:

	Transport_Read_Protocol_Handler( Instance_IM* instance = 0
		,Msg_Connection* connection = 0
		,Msg_Connection_Handler* handle = 0 );

	int service( Bit_Read_Buffer& buf, void* act );

	void dispatchMessage( Msg_Connection_Handler& handler , const DataHeader& ph, Msg_Read_Result& resule );
	void resetBuffer( size_t len ,size_t header );
	const DataHeader* getHeader();

private:

	friend class Transport_Read_Header_State;
	friend class Transport_Read_Body_State;
	friend class Transport_Write_State;
	friend class Transport_Protocol_State_T< Transport_Read_Protocol_Handler >;

	Bit_Read_Buffer* buf_;
	size_t length_;
	std::vector< iovec > vec_buf_;
};



class Transport_Write_Protocol_Handler : public Transport_Protocol_Handler
{
public:

	Transport_Write_Protocol_Handler( Instance_IM* instance = 0
		,Msg_Connection* connection = 0
		,Msg_Connection_Handler* handle = 0  );

	int service(  const Bit_Write_Buffer& buf, void* act );

private:

	friend class Transport_Read_Header_State;
	friend class Transport_Read_Body_State;
	friend class Transport_Write_State;
	friend class Transport_Protocol_State_T< Transport_Write_Protocol_Handler >;

	std::vector< iovec > vec_buf_;
	size_t length_;
	const Bit_Write_Buffer* buf_;

};

_im_end

#endif // IM_PROTOCOL_HANDLER_H