

#include "ConnectionManager.h"


_im_begin

template< ConnectionManager_ST_1 >
ConnectionManager< ConnectionManager_ST_2 >::ConnectionManager(void)
{
	toString_ = "连接管理器";
}

template< ConnectionManager_ST_1 >
ConnectionManager< ConnectionManager_ST_2 >::~ConnectionManager(void)
{
}

template< ConnectionManager_ST_1 >
typename ConnectionManager< ConnectionManager_ST_2 >::connection_ptr ConnectionManager< ConnectionManager_ST_2 >::find( const tstring& addr )
{
	connection_ptr ptr;
	iterator it = connections_.find( addr );
	if( it != connections_.end() )
		ptr = it->second;
	return ptr;
}

template< ConnectionManager_ST_1 >
bool ConnectionManager< ConnectionManager_ST_2 >::add( const tstring& addr , connection_ptr connection )
{
	iterator it = connections_.find( addr );
	if( it != connections_.end() )
		return false;
	connections_.insert( std::make_pair( addr, connection ) );

	//toString_ = "连接管理器[" + toString( connections_.size() ) + "]";
	return true;
}

template< ConnectionManager_ST_1 >
bool ConnectionManager< ConnectionManager_ST_2 >::remove( const tstring& addr )
{
	iterator it = connections_.find( addr );
	if( it == connections_.end() )
		return false;
	connections_.erase( it );
	//toString_ = "连接管理器[" + toString( connections_.size() ) + "]";
	return true;
}

template< ConnectionManager_ST_1 >
bool ConnectionManager< ConnectionManager_ST_2 >::remove( const tstring& addr , connection_ptr& connection )
{
	iterator it = connections_.find( addr );
	if( it == connections_.end() )
		return false;
	connection = it->second;
	connections_.erase( it );
	//toString_ = "连接管理器[" + toString( connections_.size() ) + "]";
	return true;
}

template< ConnectionManager_ST_1 >
void ConnectionManager< ConnectionManager_ST_2 >::clear()
{
	connections_.clear();
}

template< ConnectionManager_ST_1 >
typename ConnectionManager< ConnectionManager_ST_2 >::iterator ConnectionManager< ConnectionManager_ST_2 >::begin( )
{
	return connections_.begin();
}

template< ConnectionManager_ST_1 >
typename ConnectionManager< ConnectionManager_ST_2 >::iterator ConnectionManager< ConnectionManager_ST_2 >::end( )
{
	return connections_.end();
}

template< ConnectionManager_ST_1 >
const tstring& ConnectionManager< ConnectionManager_ST_2 >::toString() const
{
	return toString_;
}


_im_end