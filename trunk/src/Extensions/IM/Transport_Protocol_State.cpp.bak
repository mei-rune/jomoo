#include "StdAfx.h"
#include "Transport_Protocol_State.H"



#ifdef _MEMORY_DEBUG
#undef THIS_FILE
#define new	   DEBUG_NEW  
#define malloc DEBUG_MALLOC  
static char THIS_FILE[] = __FILE__;  
#endif // _MEMORY_DEBUG

_im_begin



Transport_Read_Header_State* Transport_Read_Header_State::get()
{
	static Transport_Read_Header_State state;
	return &state;
}

int Transport_Read_Header_State::service( Transport_Read_Protocol_Handler& data )
{
	return data.connection_->transport().read( data,data.vec_buf_[0].buf
		,data.length_, 0 );
}

Transport_Protocol_State* Transport_Read_Header_State::transition( Transport_Read_Protocol_Handler& data,
																	  im_transport_handler_type::read_result_type& result , void* act )
{
	if( !result.success() || result.bytes_to_transferred() == 0 )
	{
		/// Tcp错误
		Msg_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_SYS, data.act_ );
		data.handle_->onException( r );
		return 0;
	}

	if( data.length_ < result.bytes_to_transferred() )
	{
		/// 多读了数据，一般这是不可能的
		Msg_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_LEN, data.act_ );
		data.handle_->onException( r );
		return 0;
	}
	
	data.length_ -= result.bytes_to_transferred();

	data.vec_buf_[0].buf += result.bytes_to_transferred();
	data.vec_buf_[ 0 ].len -= result.bytes_to_transferred();
	if( data.length_ > 0 )
		return get();  /// 没有读全，继续读下去

	// 读全了检测内存空间是否足够
	const DataHeader* ph = data.getHeader();
	if( ph->messageSize > data.instance_->getDefaultsAndOverrides().maxMessageSize )
	{
		/// 消息长度太长，太于配置值，或大于数据块的长度
		Msg_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_MAXMSGLEN, data.act_ );
		data.handle_->onException( r );
		return 0;
	}
	if( ph->messageSize < sizeof( DataHeader ) )
	{
		Msg_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_HEADERLENGTH, data.act_ );
		data.handle_->onException( r );
		return 0;
	}
	
	if( ph->messageSize == sizeof( DataHeader ) )
	{
		// 读消息完成
		Msg_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( true, ERR_HEADERTYPE , data.act_);
		data.dispatchMessage( *data.handle_ , *ph , r );
		return 0;
	}

	try
	{
		data.vec_buf_.clear();
		data.resetBuffer(  ph->messageSize , sizeof( DataHeader ) );
		/// 消息头读完成，开始读消息体
		return Transport_Read_Body_State::get();
	}
	catch( std::runtime_error& e )
	{
		BT_LOG_ERROR( data.getLogger(), 
			data.toString() << BT_TEXT("> 读消息头时，重分配内存失败,") << e.what() <<  BT_TEXT( "!" ) );
	}
	catch( ... )
	{
		BT_LOG_ERROR( data.getLogger(), 
			data.toString() << BT_TEXT("> 读消息头时，重分配内存发生未知异常!" ) );
	}
	Msg_Read_Result r( *(data.buf_), 
		*(data.handle_) ,*(data.connection_) );
	r.set( false, ERR_MEMORY, data.act_ );
	data.handle_->onException( r );
	return 0;
}

Transport_Read_Body_State* Transport_Read_Body_State::get()
{
	static Transport_Read_Body_State state;
	return &state;
}

int Transport_Read_Body_State::service( Transport_Read_Protocol_Handler& data )
{
	BT_ASSERT( data.getLogger(), !data.vec_buf_.empty() , BT_TEXT("写读的内存不能为空") );

	do
	{
		if( data.vec_buf_.empty() )
			break;
		iovec& v = data.vec_buf_[ 0 ];
		if( v.len != 0 )
			return data.connection_->transport().read( data,v.buf,v.len ,0);
		data.vec_buf_.erase( data.vec_buf_.begin() );
	}while( true );

	// 读消息完成,注意如果运行到这是是不正常的。
	//Msg_Read_Result r( *(data.buf_), 
	//	*(data.handle_) ,*(data.connection_) );
	//r.set( true, ERR_HEADERTYPE , data.act_);
	//const DataHeader* ph = data.getHeader();
	//data.dispatchMessage( *data.handle_ , *ph , r );
	return -1;
}

Transport_Protocol_State* Transport_Read_Body_State::transition( 
	Transport_Read_Protocol_Handler& data,
	im_transport_handler_type::read_result_type& result , void* act )
{
	if( !result.success() || result.bytes_to_transferred() == 0 )
	{
		/// Tcp错误
		Msg_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_SYS, data.act_ );
		data.handle_->onException( r );
		return 0;
	}

	if( result.length() > result.bytes_to_transferred() )
	{
		/// 多读了数据，一般这是不可能的
		Msg_Read_Result r( *(data.buf_), 
			*(data.handle_) ,*(data.connection_));
		r.set( false, ERR_LEN, data.act_  );
		data.handle_->onException( r );
		return 0;
	}

	data.length_ -= result.bytes_to_transferred();
	
	iovec* v = &( data.vec_buf_[0]);
	v->buf += result.bytes_to_transferred();
	v->len -= result.bytes_to_transferred();

	while( true )
	{
		if( v->len != 0 )
			return get();   /// 没有读全，继续读下去

		data.vec_buf_.erase( data.vec_buf_.begin() );
		if( data.vec_buf_.empty() )
			break;
		iovec* v = &( data.vec_buf_[0]);
	}

	/// 消息读完成
	Msg_Read_Result r( *(data.buf_),
			*(data.handle_) ,*(data.connection_));
	r.set( true, ERR_HEADERTYPE , data.act_ );
	
	const DataHeader* ph = data.getHeader();
    data.dispatchMessage( *data.handle_ , *ph , r );
	return 0;
}


Transport_Write_State* Transport_Write_State::get()
{
	static Transport_Write_State state;
	return &state;
}

int Transport_Write_State::service( Transport_Write_Protocol_Handler& data )
{
	BT_ASSERT( data.getLogger(), !data.vec_buf_.empty() , "可读内存不能为空!" );

	do
	{
		if( data.vec_buf_.empty() )
			break;
		iovec& v = data.vec_buf_[ 0 ];
		if( v.len != 0 )
			return data.connection_->transport().write( data,v.buf,v.len ,0);
		data.vec_buf_.erase( data.vec_buf_.begin() );
	}while( true );

	// 读消息完成,注意如果运行到这是是不正常的。
	//Msg_Write_Result r( *(data.buf_), *(data.handle_) ,*(data.connection_) );
	//r.set( true, ERR_HEADERTYPE , data.act_);
	//data.handle_->onWriteMessage( r );
	
	return -1;
}

Transport_Protocol_State* Transport_Write_State::transition( 
	Transport_Write_Protocol_Handler& data,
	im_transport_handler_type::write_result_type& result , void* act )
{
	if( !result.success() || result.bytes_to_transferred() == 0 )
	{
		/// Tcp错误
		Msg_Write_Result r( *(data.buf_),
			*(data.handle_) ,*(data.connection_));
		r.set( false, ERR_SYS, data.act_  );
		data.handle_->onWriteMessage( r );
		return 0;
	}

	if( result.length() < result.bytes_to_transferred() )
	{
		/// 多发送了数据，这一般是不可能的
		Msg_Write_Result r( *(data.buf_),
			*(data.handle_) ,*(data.connection_) );
		r.set( false, ERR_LEN, data.act_ );
		data.handle_->onWriteMessage( r );
		return 0;
	}


	iovec* v = &( data.vec_buf_[0]);
	v->buf += result.bytes_to_transferred();
	v->len -= result.bytes_to_transferred();
	while( true )
	{
		if( v->len != 0 )
			return get();   /// 没有读全，继续读下去

		data.vec_buf_.erase( data.vec_buf_.begin() );
		if( data.vec_buf_.empty() )
			break;
		iovec* v = &( data.vec_buf_[0]);
	}

	/// 发送完成
	Msg_Write_Result r( *(data.buf_),
		*(data.handle_) ,*(data.connection_) );
	r.set( true, 0 , data.act_);
	data.handle_->onWriteMessage( r );
	return 0;
}


_im_end